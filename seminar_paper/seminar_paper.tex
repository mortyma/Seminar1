\documentclass[a4paper,10pt, twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage{tikz}
\usepackage{verbatim}
\usetikzlibrary{arrows,shapes}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{enumitem}
\setlist{nolistsep}
\setlength{\parindent}{0cm}

%page boarders
\usepackage[top=3cm, bottom=3cm, left=2cm, right=2cm]{geometry}
\usepackage[style=numeric,backend=bibtex]{biblatex}
\addbibresource{../sources}
%\usepackage[style=mla,babel=hyphen,backend=biber]{biblatex}

\tikzstyle{vertex}=[circle,fill=black!25,minimum size=20pt,inner sep=0pt]
\tikzstyle{edge} = [draw,thick,->,>=latex,shorten >=1pt]
\tikzstyle{weight} = [font=\small]
\tikzstyle{selected edge} = [draw,line width=2pt,->,red!75,>=latex]
\tikzstyle{residual edge} = [draw,thick,->,blue!75,>=latex]
\tikzstyle{vertexE}=[circle,fill=black!25,minimum size=20pt,inner sep=0pt]

% Declare layers (for more convenience when drawing graphs)
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

\newtheorem{lemma}{Lemma}
\newtheorem{corollary}[lemma]{Corollary}
%\newtheorem{proof}[lemma]{Proof}

\title{Parallel Network Flow Algorithms \\ 
\large A follow up seminar to the Parallel Algorithms lecture\footnote{Jesper Larsson TrÃ¤ff, lecture "Parallel Algorithms", 2012 winter term at TU Wien}}
\author{Martin Kalany, 0825673}

\begin{document}
\maketitle

\section{Abstract}
\label{sec:abstract}

\section{Introduction}
\label{sec:intro}
\emph{Maximum flow problem}\footnote{Henceforth called \lstinline|MAX-FLOW| for brevity}


\section{Network flows}
\label{sec:networkFlows}
A \textbf{flow network} \cite{ahuja93} is given by $N = (G,s,t,c)$, where
\begin{itemize}
	\item $G =(V,E)$ is a directed graph
    \item $s$ and $t$, $s \neq t$ are the source and terminal node
   	\item $c:E\rightarrow \mathbb{R}_0^{+}$ assigns a capacity $\forall a \in E$
   	\item $n=\lvert V\rvert$, $m=\lvert E\rvert$
\end{itemize}

Furthermore, the following assumptions are made:
\begin{itemize}
	\item $G$ is connected
	\item $G$ is simple, i.e., does not contain loops or parallel arcs
	\item $\nexists P(s,t)$ with infinite capacity
\end{itemize}

\medskip
$f:E \rightarrow \mathbb{R}_0^{+}$ is a \textbf{flow} if it satisfies:
\begin{itemize}
	\item \emph{Capacity constraints:} $f(e) \leq c(e)$ $\forall e \in E$
	\item \emph{Flow conservation:} 
	$ \sum\limits_{v \in V} f(u,v) =  0 \Leftrightarrow IN(f,v) = OUT(f,v)$ $\forall v \in V \setminus \{s,t\}$
	\item \emph{Skew symmetry:} $f(v,w) = -f(w,v)$
	\item \emph{Value of a flow:} $\lvert f\rvert = f(V,t)$ 
\end{itemize}

A flow $f$
\begin{itemize}
	\item is a \emph{maximum flow} if $\lvert f\rvert \geq \lvert f'\rvert$, for any other flow $f'$
	\item \emph{saturates} an arc e if $f(e) = c(e)$
	\item is a \emph{maximal (or blocking) flow} if every directed path P(s,t) contains at least one saturated arc
\end{itemize}
\medskip
The \emph{residual capacity} of $e \in V \times V$ w.r.t. a flow $f$ is defined as $c_r(e) = c(e) - f(e)$. $G_r = (V, E_r)$ is the \emph{residual network}, where $E_r = \left\{e \in V \times V \lvert c_r(e) > 0\right\}$. A path $P$ from $s$ to $t$ in $G_r$ is called an \emph{augmenting path} and can be used to increase the flow $f$.

\section{Algorithm of Ford-Fulkerson}
\label{sec:fordfulkerson}

\section{Computitional Complecity}
\label{sec:cc}
The algorithmic complexity of the \emph{Ford-Fulkerson} algorithm is given as $O((n+m)*f_{max})$\footnote{$f_{max}$ is from here on used to denote the maximum flow} \cite{ahuja93,papa95}. This was improved by the \emph{Edmonds-Karp} algorithm to $O(n*m^2)$, by using shortest augmenting paths instead of arbitrarily chosen ones. Clearly, the \emph{maximum flow problem} can be solved in polynomial time with a sequential algorithm and is thus $\in P$.

Informally, algorithms may be \emph{efficiently parallelizeable} or \emph{inherently sequential}. The complexity class \textbf{NC} \cite{papa95} ("Nick's Class") contains all problems solvable in $O(log^{k_1}(n))$ time and $O(n^{k_2})$ total work. We give a useful alternate definition:  A language that is decided by PRAM in $O(log^{k_1}(n))$ time steps with $O(n^{k_2})$ processors available at each step is in $NC$. Problems $\in NC$ thus are solvable  in poly-logarithmic time requiring polynomial work (or resources). Problems $P \setminus NC$ are dubbed "inherently sequential", i.e., not parallelizeable efficiently. 

Clearly, $NC \subseteq P$, but whether $NC \subset P$ or $NC = P$ is still unknown. It follows that we do not know whether or not inherently sequential problems actually exist. The most likely problems to be hard to parallelize are P-complete problems. Since any problem $A \in P$ can be reduced to a P-complete problem $B$, a parallel algorithm that solves $B$ within poly-logarithmic time bounds would immediately imply that for all problems $\in P$ a parallel algorithm $\in NC$ exists \cite{papa95}.

As an example, the Ford-Fulkerson algorithm can not be parallelized trivially. Although constructing the residual network can be done in constant time $O(1)$ by assigning a processor to each edge $a \in E$ and augmenting paths can be found in $O(log^{2}n)$ time and $O(n^{2})$ work by a basic BFS search, the number of stages can not be reduced to less than $O(\sqrt(n))$ \cite{ahuja93}. Thus the total complexity, which is dominated by the number of stages, places the algorithm in $P \setminus NC$.
	
As shown in \cite{papa95}, \lstinline|MAX-FLOW| is P-complete and no parallel algorithm $\in NC$ is currently known for solving this problem. It is assumed that the problem is inherently sequential.

\section{Dinitz' scheme}
\label{sec:dinitz}
$N = (V,E,s,t,c)$ is a \textbf{layered network} \cite{yossi81} if each vertex $v \in V$ has a layer number $l(v)$ s.t.
\begin{itemize}
	\item $l(s) = 0$ and $0 \leq l(v) \leq l(t)$ $\forall v \in V$
	\item $(e = u \rightarrow v) \in E  \Rightarrow l(v) - l(u) = 1$
\end{itemize}
Figure \ref{fig:dinitz} shows a layered network and it's underlying directed acyclic network.

\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=1.2, auto,swap]
   	% draw the vertices
	\foreach \pos/\name/\layer in {{(0,2)/s/0}, {(1,3)/v_1/1}, {(2.5,3)/v_2/2},
    	                        {(1,1)/v_3/1}, {(2.5,1)/v_4/2}, {(3.5,2)/t/3}}
    \node[vertex,label={[color=blue]80:$\layer$}] (\name) at \pos {$\name$};
        
    %\node[vertex,label={[color=blue]80:$+12$}] (v_1) at (1.5,3) {$v_1$};
    % Connect vertices with edges and draw weights
    \foreach \source/ \dest in {s/v_1, s/v_3,v_3/v_1,
                                        v_1/v_2, v_4/v_2, v_3/v_4,
                                        v_2/t, v_4/t}
     \path[edge] (\source) -- (\dest);
        	
     %v_1/v_4/9
     \path[edge] ([xshift= -2pt, yshift= 5pt] v_4.center) -- ([xshift= 5pt, yshift= -2pt] v_1.center);
     \path[edge] ([xshift = 2pt, yshift= -5pt] v_1.center) -- ([xshift= -5pt, yshift= 2pt] v_4.center);
  
	% For convenience we use a background layer to highlight edges
    % This way we don't have to worry about the highlighting covering
	% weight labels. 
	\begin{pgfonlayer}{background}
    	\foreach \source /\dest in {s/v_3,v_2/t,s/v_1,v_1/v_2,v_3/v_4,v_4/t}
	      	\path[selected edge, color=blue] (\source) -- (\dest);		
	    \path[selected edge, color=blue] ([xshift = 2pt, yshift= -5pt] v_1.center) -- ([xshift= -5pt, yshift= 2pt] v_4.center);
	\end{pgfonlayer}
\end{tikzpicture}
\end{center}
\caption{A layered network (in blue) with layer numbers and it's underlying network}
\label{fig:dinitz}
\end{figure}

\begin{lemma}
\textbf{Dinitz' scheme} \cite{dinitz70} \\
A maximum flow problem in a general network can be transformed into $O(n)$ maximal flow problems in layered networks.
\end{lemma}

A layered network can easily be constructed from a directed acyclic network by performing breath-first search in  $O(log^{2}n)$ time. It follows that an algorithm that finds a maximal/blocking flow in a layered network can solve \lstinline|MAX-FLOW| in $O(n)$ iterations. The basic scheme is given in Algorithm \ref{algo:dinitz}

%TODO: remove comments?
\begin{algorithm}
\caption{Dinitz' scheme}
\label{algo:dinitz}
\begin{algorithmic}[1]
	\Function{MAX-FLOW}{$N=(V,E,s,t,c)$}
	\State start with some valid flow 
	\While{$l(t) \neq \infty$} \Comment{\textcolor{OliveGreen}{$O(n)$}}	
		\State Construct residual network $G_r$ \Comment{\textcolor{OliveGreen}{$O(n)$, $p=O(n)$}}
		\State Construct layered network $G_l$ from $G_r$ \Comment{\textcolor{OliveGreen}}{$O(m/p + n)$}
		\State $f_l$ = MAX-FLOW($G_l$)  \Comment{tbd}
		\State $f$ = $f$ + $f_l$ \Comment{\textcolor{OliveGreen}{$O(n)$}}
	\EndWhile
	\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithm of Shiloach and Vishkin}
\label{sec:shiloach}

\section{Algorithm of Goldberg and Tarjan}
\label{sec:goldberg}

\section{Further results}
\label{sec:further}

\section{bla}
text \cite{ahuja93} \cite{papa95} \cite{yossi81} \cite{vishkin92} \cite{goldberg89} \cite{goldberg91} \cite{goldberg98} \cite{johnson87} \cite{schieber89} \cite{cherivan89} 

%\pagebreak
\printbibliography
\end{document}
